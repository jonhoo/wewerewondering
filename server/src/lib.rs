use aws_sdk_dynamodb::types::AttributeValue;
use axum::routing::{get, post};
use axum::Router;
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::time::Duration;
use tower_http::limit::RequestBodyLimitLayer;
use ulid::Ulid;

mod ask;
mod event;
mod list;
mod new;
mod questions;
mod toggle;
mod utils;
mod vote;

pub use ask::Question;
pub use utils::to_dynamo_timestamp;
pub use vote::UpDown;

#[cfg(debug_assertions)]
const SEED: &str = include_str!("test.json");

const QUESTIONS_EXPIRE_AFTER_DAYS: u64 = 30;
const QUESTIONS_TTL: Duration = Duration::from_secs(QUESTIONS_EXPIRE_AFTER_DAYS * 24 * 60 * 60);

const EVENTS_EXPIRE_AFTER_DAYS: u64 = 60;
const EVENTS_TTL: Duration = Duration::from_secs(EVENTS_EXPIRE_AFTER_DAYS * 24 * 60 * 60);

#[derive(Clone, Debug, Default)]
pub struct Local {
    pub events: HashMap<Ulid, String>,
    pub questions: HashMap<Ulid, HashMap<&'static str, AttributeValue>>,
    pub questions_by_eid: HashMap<Ulid, Vec<Ulid>>,
}

#[derive(Clone, Debug)]
pub enum Backend {
    Dynamo(aws_sdk_dynamodb::Client),
    Local(Arc<Mutex<Local>>),
}

impl Backend {
    #[allow(unused)]
    async fn local() -> Self {
        Backend::Local(Arc::new(Mutex::new(Local::default())))
    }

    /// Instantiate a DynamoDB backend.
    ///  
    /// If `USE_DYNAMODB` is set to "local", the `AWS_ENDPOINT_URL` will be taken
    /// from the environment with the "http://localhost:8000" fallback , the `AWS_DEFAULT_REGION`
    /// will be pulled from the environment as well and will default to "us-east-1",
    /// as for the credentials - the [test credentials](https://docs.rs/aws-config/latest/aws_config/struct.ConfigLoader.html#method.test_credentials)
    /// will be used to sign requests.
    ///
    /// This spares setting those environment variables (including `AWS_ACCESS_KEY_ID`
    /// and `AWS_SECRET_ACCESS_KEY`) via the command line or configuration files,
    /// and allows to run the application against a local dynamodb instance with just:
    /// ```sh
    /// USE_DYNAMODB=local cargo run
    /// ```
    /// While the entire test suite can be run with:
    /// ```sh
    /// USE_DYNAMODB=local cargo t -- --include-ignored
    /// ```
    ///
    /// This also allows us to use the local instance of DynamoDB which is running
    /// in a container on the same network, in which case the database will be accessible
    /// under `http://<dynamodb_container_name>:<port>`. This facilitates the setup of
    /// local API Gateway with SAM, since the `sam local start-api` command will launch our
    /// back-end app in a docker container.
    ///
    /// If more customization is needed (say, you want to set some specific credentials
    /// rather than rely on those test creds generated by the `aws_config` crate),
    /// set `USE_DYNAMODB` to e.g. "custom", and set the environment variables to whatever
    /// values you need or let them be picked up from your `~/.aws` files
    /// (see [`aws_config::load_from_env`](https://docs.rs/aws-config/latest/aws_config/fn.load_from_env.html))
    pub async fn dynamo() -> Self {
        let config = if std::env::var("USE_DYNAMODB")
            .ok()
            .is_some_and(|v| v == "local")
        {
            aws_config::from_env()
                .endpoint_url(
                    std::env::var("AWS_ENDPOINT_URL")
                        .ok()
                        .unwrap_or("http://localhost:8000".into()),
                )
                .region(aws_config::Region::new(
                    std::env::var("AWS_DEFAULT_REGION")
                        .ok()
                        .unwrap_or("us-east-1".into()),
                ))
                .test_credentials()
                .load()
                .await
        } else {
            aws_config::load_from_env().await
        };
        Backend::Dynamo(aws_sdk_dynamodb::Client::new(&config))
    }
}

pub async fn new() -> Router {
    #[cfg(not(debug_assertions))]
    let backend = Backend::dynamo().await;

    #[cfg(debug_assertions)]
    let backend = {
        use rand::prelude::IndexedRandom;

        let mut backend = if std::env::var_os("USE_DYNAMODB").is_some() {
            Backend::dynamo().await
        } else {
            Backend::local().await
        };

        // to aid in development, seed the backend with a test event and related
        // questions, and auto-generate user votes over time
        let qids = crate::utils::seed(&mut backend).await;
        let cheat = backend.clone();
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(Duration::from_secs(1));
            interval.tick().await;
            loop {
                interval.tick().await;
                let qid = qids
                    .choose(&mut rand::rng())
                    .expect("there _are_ some questions for our test event");
                let _ = cheat.vote(qid, vote::UpDown::Up).await;
            }
        });

        backend
    };

    Router::new()
        .route("/api/event", post(new::new))
        .route("/api/event/{eid}", post(ask::ask))
        .route("/api/event/{eid}", get(event::event))
        .route("/api/event/{eid}/questions", get(list::list))
        .route("/api/event/{eid}/questions/{secret}", get(list::list_all))
        .route(
            "/api/event/{eid}/questions/{secret}/{qid}/toggle/{property}",
            post(toggle::toggle),
        )
        .route("/api/vote/{qid}/{updown}", post(vote::vote))
        .route("/api/questions/{qids}", get(questions::questions))
        .layer(RequestBodyLimitLayer::new(1024))
        .with_state(backend)
}
